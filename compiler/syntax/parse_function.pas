(*
 Copyright Â© by Patryk Wychowaniec, 2013
 All rights reserved.
*)
Unit Parse_FUNCTION;

 Interface
 Uses MTypes, Tokens, Variants;

 Procedure Parse(Compiler: Pointer);
 Function CreateFunctionMangledName(CompilerPnt: Pointer; Func: TMFunction; SimplifiedName: Boolean): String;

 Implementation
Uses Compile1, Messages, Opcodes, ExpressionCompiler, SysUtils, CompilerUnit;

(* CreateFunctionMangledName *)
{
 Creates a mangled name of function passed in parameter.
}
Function CreateFunctionMangledName(CompilerPnt: Pointer; Func: TMFunction; SimplifiedName: Boolean): String;
Var Compiler: TCompiler absolute CompilerPnt;
    P       : TMParam;
Begin
 With Func do
 Begin
  if (SimplifiedName) Then
   Exit('__function_'+NamespaceName+'_'+Name);

  Result := '__function_'+NamespaceName+'_'+Name+'_'+ModuleName+'_'+Compiler.getBytecodeType(Return);
  For P in ParamList Do
   Result += Compiler.getBytecodeType(P.Typ)+'_';
 End;
End;

(* Parse *)
{
 Parses a whole function or a function declaration.
}
Procedure Parse(Compiler: Pointer);
Type TVarRecArray = Array of TVarRec;
     PVarRecArray = ^TVarRecArray;
Var CList: TMConstructionList;
    Func : TMFunction; // our new function
    c_ID : Integer;

{ ParseConstruction }
Procedure ParseConstruction(ID: Integer);

{ ParseUntil }
Procedure ParseUntil(M: TMConstructionType);
Begin
 Inc(c_ID);
 While (CList[c_ID].Typ <> M) Do // parse loop
 Begin
  ParseConstruction(c_ID);
  Inc(c_ID);
 End;
End;

{ RemoveRedundantPushes }
Procedure RemoveRedundantPushes;
Begin
 With TCompiler(Compiler) do
 Begin
  (*
   Remove push-es generated by the expression compiler

   (expression compiler 'push'-es expression's result onto the stack, and - as we don't always need those results - we can* remove them)
    *in fact - we `have to` remove them, because one redundant `push` can make a lot of bad things (just trust me ._.)
  *)
  While (OpcodeList.Last^.Opcode = o_push) Do
   With OpcodeList.Last^ do
    OpcodeList.Delete(OpcodeList.Count-1);
 End;
End;

// main function's block
Var Str1, Str2, Str3, Str4: String;
    EType                 : PMType;
    Item                  : PMOpcode;
Begin
With TCompiler(Compiler) do
Begin
 if (ID > High(CList)) Then
  Exit;
 With CList[ID] do
 Begin
  Case Typ of
(* ctJump *)
   ctJump:
   Begin
    PutOpcode(o_jmp, [PChar(Values[0])]);
   End;

(* ctLabel *)
   ctLabel:
   Begin
    if (findLabel(PChar(Values[0])) <> -1) Then
     CompileError(PToken_P(Values[1])^, eRedeclaration, [PChar(Values[0])]);

    New(Item);
    With Item^ do
    Begin
     Name    := PChar(Values[0]);
     isLabel := True;
    End;
    OpcodeList.Add(Item);
   End;

(* ctExpression *)
   ctExpression:
   Begin
    ExpressionCompiler.CompileConstruction(Compiler, Values[0]);
    RemoveRedundantPushes;
   End;

(* ctReturn *)
   ctReturn:
   Begin
    EType := ExpressionCompiler.CompileConstruction(Compiler, Values[0]);

    if (not CompareTypes(Func.Return, EType)) Then // type check
     CompileError(PMExpression(Values[0])^.Token, eWrongType, [getTypeDeclaration(EType), getTypeDeclaration(Func.Return)]);

    if (OpcodeList.Last^.Opcode = o_push) Then // result must be in the `e_1` register, not on the stack
     PutOpcode(o_pop, ['e'+getTypePrefix(Func.Return)+'1']);

    if (not Func.isNaked) Then
     PutOpcode(o_jmp, [':'+Func.MName+'_end']) Else
     PutOpcode(o_ret);
   End;

(* ctVoidReturn *)
   ctVoidReturn:
   Begin
    if (not isTypeVoid(Func.Return)) Then // type check
     CompileError(PToken_P(Values[0])^, eWrongType, [getTypeDeclaration(TYPE_VOID), getTypeDeclaration(Func.Return)]);
    PutOpcode(o_ret);
   End;

(* ctInlineBytecode *)
   ctInlineBytecode: PutOpcode(PChar(Values[0]), PVarRecArray(Values[1])^, LongWord(Values[2]));

(* ctFOR *)
   ctFOR:
   Begin
    Str1 := PChar(Values[2]);
    Str2 := Str1+'condition';
    Str3 := Str1+'end';

    { condition }
    PutLabel(Str2);
    EType := ExpressionCompiler.CompileConstruction(Compiler, Values[0]);
    if (not isTypeBool(EType)) Then
     CompileError(PMExpression(Values[0])^.Token, eWrongType, [getTypeDeclaration(EType), getTypeDeclaration(TYPE_BOOL)]);

    { condition check }
    PutOpcode(o_pop, ['if']);
    PutOpcode(o_fjmp, [':'+Str3]);

    ParseUntil(ctFOR_end);

    { step }
    ExpressionCompiler.CompileConstruction(Compiler, Values[1]);
    if (OpcodeList.Last^.Opcode = o_push) Then // remove last `push` opcode created by ExpressionCompiler.
     OpcodeList.Delete(OpcodeList.Count-1);

    PutOpcode(o_jmp, [':'+Str2]);

    PutLabel(Str3); { end }
   End;

(* ctIF *)
   ctIF:
   Begin
    Str1 := PChar(Values[1]);
    Str2 := Str1+'true';
    Str3 := Str1+'false';
    Str4 := Str1+'end';

    { condition }
    EType := ExpressionCompiler.CompileConstruction(Compiler, Values[0]);
    if (not isTypeBool(EType)) Then
     CompileError(PMExpression(Values[0])^.Token, eWrongType, [getTypeDeclaration(EType), getTypeDeclaration(TYPE_BOOL)]);

    { jump }
    PutOpcode(o_pop, ['if']);
    PutOpcode(o_tjmp, [':'+Str2]);
    PutOpcode(o_jmp, [':'+Str3]); // or 'o_fjmp' - from here it doesn't matter, but `o_jmp` is slightly faster (as it doesn't check `if` register's value)

    { on true }
    PutLabel(Str2);
    ParseUntil(ctIF_end);
    PutOpcode(o_jmp, [':'+Str4]);

    PutLabel(Str3);

    { on false }
    if (CList[c_ID+1].Typ = ctIF_else) Then // compile 'else'
    Begin
     Inc(c_ID); // skip `ctIF_else`
     ParseUntil(ctIF_end);
    End;

    PutLabel(Str4);
   End;

(* ctWHILE *)
   ctWHILE:
   Begin
    Str1 := PChar(Values[1]);
    Str2 := Str1+'condition';
    Str3 := Str1+'end';

    { condition (loop begin) }
    PutLabel(Str2);
    EType := ExpressionCompiler.CompileConstruction(Compiler, Values[0]);
    if (not isTypeBool(EType)) Then
     CompileError(PMExpression(Values[0])^.Token, eWrongType, [getTypeDeclaration(EType), getTypeDeclaration(TYPE_BOOL)]);

    { condition check }
    PutOpcode(o_pop, ['if']);
    PutOpcode(o_fjmp, [':'+Str3]);

    { loop body }
    ParseUntil(ctWHILE_end);

    PutOpcode(o_jmp, [':'+Str2]);

    { loop end }
    PutLabel(Str3);
   End;

(* ct_DO_WHILE *)
   ct_DO_WHILE:
   Begin
    Str1 := PChar(Values[0]);
    Str2 := Str1+'begin';
    Str3 := Str1+'end';

    { loop begin }
    PutLabel(Str2);

    { parse loop }
    ParseUntil(ct_DO_WHILE_end);

    { condition }
    With CList[c_ID] do
    Begin
     EType := ExpressionCompiler.CompileConstruction(Compiler, Values[0]);
     if (not isTypeBool(EType)) Then
      CompileError(PMExpression(Values[0])^.Token, eWrongType, [getTypeDeclaration(EType), getTypeDeclaration(TYPE_BOOL)]);
    End;

    { condition check }
    PutOpcode(o_pop, ['if']);
    PutOpcode(o_tjmp, [':'+Str2]);

    { loop end }
    PutLabel(Str3);
   End;

(* ctDELETE *)
   ctDELETE:
   Begin
    EType := ExpressionCompiler.CompileConstruction(Compiler, Values[0]);
    if (not isTypeObject(EType)) Then
     CompileError(PMExpression(Values[0])^.Token, eWrongType, [getTypeDeclaration(EType), 'object']);

    PutOpcode(o_pop, ['er1']);
    PutOpcode(o_objfree, ['er1']);
   End;

(* ctTRY *)
   ctTRY:
   Begin
    { save current exception handler and set the new one }
    PutOpcode(o_icall, ['"vm.save_exception_handler"']);
    PutOpcode(o_push, ['@'+PChar(Values[0])]);
    PutOpcode(o_icall, ['"vm.set_exception_handler"']);

    { parse `try` block }
    ParseUntil(ctCatch);
    PutOpcode(o_jmp, [':'+PChar(Values[0])+'_end']);

    { parse `catch` block }
    PutLabel(PChar(Values[0]));
    PutOpcode(o_icall, ['"vm.restore_exception_handler"']); // restore previous exception handler

    ParseUntil(ctCATCH_END);
    PutLabel(PChar(Values[0])+'_end');
   End;

   else
    CompileError(eInternalError, ['Unexpected construction: '+IntToStr(ord(Typ))]);
  End;
 End;
End;
End;

// NewConst
Procedure NewConst(const Name: String; Typ: PMType; Value: PMExpression);
Var Variable: TMVariable;
Begin
 With TCompiler(Compiler) do
 Begin
  Variable.Name      := Name;
  Variable.Deep      := 0;
  Variable.Typ       := Typ;
  Variable.RegID     := 0;
  Variable.Value     := Value;
  Variable.isConst   := True;
  Variable.mCompiler := Compiler;
  Variable.DeclToken := getToken;

  if (findLocalVariable(Name) = -1) Then // don't duplicate
  Begin
   With getCurrentFunctionPnt^ do
   Begin
    SetLength(VariableList, Length(VariableList)+1);
    VariableList[High(VariableList)] := Variable;
   End;
  End;
 End;
End;

// main function block
Var I, AllocatedVars, SavedRegs: Integer;
    Token                      : TToken_P;
    Namespaces                 : Array of Integer;
Begin
 Func.mCompiler := Compiler;

With TCompiler(Compiler) do
Begin
 // make a backup of current namespaces (as we'll restore them when we'll finish compiling this namespace)
 SetLength(Namespaces, Length(SelectedNamespaces));
 For I := Low(Namespaces) To High(Namespaces) Do
  Namespaces[I] := SelectedNamespaces[I];

 Func.DeclToken     := getToken(-1); // _FUNCTION
 Func.NamespaceName := getCurrentNamespace.Name;

 { read function return type }
 eat(_LOWER); // <
 Func.Return := read_type; // [type]
 eat(_GREATER); // >

 { read function name and check for duplicates (redeclaration) }
 Func.Name          := read_ident; // [identifier]
 Func.ModuleName    := ModuleName;
 Func.LibraryFile   := '';
 Func.isDeclaration := False;
 Func.Visibility    := getVisibility;

 RedeclarationCheck(Func.Name); // check for redeclaration

 Case Func.Name of
  '': CompileError(eRedeclaration, [Func.Name]); // cannot redeclare internal function
 End;

 { make parameter list }
 eat(_BRACKET1_OP); // (

 SetLength(Func.ParamList, 0);
 While (next_t <> _BRACKET1_CL) Do
 Begin
  if (Length(Func.ParamList) > 0) Then
   eat(_COMMA); // parameters are separated by comma (except the very first parameter)

  With Func do
  Begin
   SetLength(ParamList, Length(ParamList)+1); // resize the param array
   With ParamList[High(ParamList)] do // read parameter
   Begin
    Typ := read_type;

    if (next_t in [_COMMA, _BRACKET1_CL]) Then
    Begin
     if (not Func.isDeclaration) and (Length(ParamList) <> 1) Then
      CompileError(next, eExpectedIdentifier, [next.Display]);

     Func.isDeclaration := True;
     Continue;
    End;

    Name := read_ident;

    if (isTypeVoid(Typ)) Then // error: void-typed param
     CompileError(eVoidParam, [Name]);

    { check duplicates }
    For I := Low(ParamList) To High(ParamList)-1 Do
     if (ParamList[I].Name = Name) Then
     Begin
      CompileError(eRedeclaration, [Name]); // error: parameter has been redeclared
      Break;
     End;
   End;
  End;
 End;
 eat(_BRACKET1_CL); // read remaining parenthesis

 { read special function attributes }
 Func.isNaked := False;

 While (true) Do
 Begin
  Token := read;
  Case Token.Token of
   _NAKED    : Func.isNaked := True;
   _IN       : Func.LibraryFile := read.Display;
   _NAMESPACE: Func.NamespaceName := read.Display;
   else Break;
  End;
 End;
 setPosition(getPosition-1); // go back 1 token

 if (Func.LibraryFile <> '') or ((TCompiler(Compiler).Parent.CompileMode = cmLibrary) and (Pointer(TCompiler(Compiler).Parent) = Compiler)) Then
  Func.MName := CreateFunctionMangledName(Compiler, Func, True) Else
  Func.MName := CreateFunctionMangledName(Compiler, Func, False); // create function mangled name

 SetLength(Func.ConstructionList, 0); // there are no constructions in this compiled function so far

 { add new function into the list }
 With getCurrentNamespacePnt^ do
 Begin
  SetLength(GlobalList, Length(GlobalList)+1);
  With GlobalList[High(GlobalList)] do
  Begin
   Typ       := gdFunction;
   mFunction := Func;

   mVariable.Name    := Func.Name;
   mVariable.Typ     := NewTypeFromFunction(Func);
   mVariable.Value   := MakeIntExpression('@'+Func.MName);
   mVariable.RegID   := 1;
   mVariable.isConst := True;
  End;
 End;

 if (Func.LibraryFile <> '') Then // if file is imported from library, we don't create any bytecode
 Begin
  semicolon;
  Exit;
 End;

 if (Func.isDeclaration) and not (next_t = _SEMICOLON) Then
  CompileError(next, eExpected, [';', next.Display]);

 { add parameters }
 With Func do
  For I := Low(ParamList) To High(ParamList) Do
   __variable_create(ParamList[I].Name, ParamList[I].Typ, -I-2, True);

 { add special constants (if `-Sconst` enabled) }
 if (getBoolOption(opt_internal_const)) Then
 Begin
  NewConst('__self', TypeInstance(TYPE_STRING), MakeStringExpression(Func.Name));
 End;

 { new label (function's beginning) }
 PutLabel(Func.MName);

 { new scope (because we're in function now) }
 NewScope(sFunction);

 { parse function's code }
 ParseCodeBlock;

 (* now, we have a full construction list used in this function; so - let's optimize and generate bytecode! :) *)
 CList := getCurrentFunction.ConstructionList;

 { allocate local-stack-variables }
 AllocatedVars := 0;

 if (not Func.isNaked) Then
 Begin
  With getCurrentFunction do
   For I := Low(VariableList) To High(VariableList) Do
    if (VariableList[I].RegID <= 0) and (not VariableList[I].isParam) and (not VariableList[I].isConst) Then
     Inc(AllocatedVars); // next variable to allocate

  PutOpcode(o_add, ['stp', AllocatedVars+1]); // `+1`, because `stack[stp]` is caller-IP (instruction pointer)
 End;

 { if register is occupied by a variable, we need to at first save this register's value (and restore it at the end of the function) }
 SavedRegs := 0;
 With getCurrentFunctionPnt^ do
 Begin
  For I := Low(VariableList) To High(VariableList) Do
   With VariableList[I] do
    if (RegID > 0) and (not isConst) Then
    Begin
     PutOpcode(o_push, ['e'+getTypePrefix(Typ)+IntToStr(RegID)]);
     Inc(SavedRegs);
    End;

  For I := Low(VariableList) To High(VariableList) Do
   With VariableList[I] do
    if (RegID <= 0) and (not isConst) Then
    Begin
     RegID -= SavedRegs;

     if (isParam) Then
      RegID -= AllocatedVars;
    End;
 End;

 { new label (main function's body; nothing should jump here, it's just facilitation for optimizer) }
 PutLabel(Func.MName+'_body');

 { parse constructions }
 c_ID := 0;
 Repeat
  ParseConstruction(c_ID);
  Inc(c_ID);
 Until (c_ID > High(CList));

 { function end code }
 PutLabel(Func.MName+'_end');

 With getCurrentFunction do
 Begin
  For I := High(VariableList) Downto Low(VariableList) Do
   With VariableList[I] do
    if (RegID > 0) and (not isConst) Then
     PutOpcode(o_pop, ['e'+getTypePrefix(Typ)+IntToStr(RegID)]);
 End;

 if (not Func.isNaked) Then
  PutOpcode(o_sub, ['stp', AllocatedVars+1]);

 PutOpcode(o_ret);
 // </>

 RemoveScope; // ... and - as we finished compiling this function - remove scope

 SetLength(SelectedNamespaces, Length(Namespaces));
 For I := Low(Namespaces) To High(Namespaces) Do
  SelectedNamespaces[I] := Namespaces[I];
End;
End;
End.
